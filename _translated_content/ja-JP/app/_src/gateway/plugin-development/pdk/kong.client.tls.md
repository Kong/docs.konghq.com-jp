---
##
#  WARNING: this file was auto-generated by a script.
#  DO NOT edit this file directly. Instead, send a pull request to change
#  https://github.com/Kong/kong/tree/master/kong/pdk
#  or its associated files
##

title: "kong.client.tls"
pdk: true
toc: true
source_url: "https://github.com/Kong/kong/tree/master/kong/pdk/client/tls.lua"
---
クライアントTLS接続モジュール。

クライアントからの TLS 接続と対話するための関数のセット。

{% if_version lte:3.1.x %}

kong.client.tls.request\_client\_certificate\(\)
----------------------------------------------------

{% endif_version %}

{% if_version gte:3.2.x %}

kong.client.tls.request\_client\_certificate\(\[ca\_certs\]\)
------------------------------------------------------------------

{% endif_version %}

クライアントとクライアント間のTLS相互認証（mTLS）を開始するために、クライアント側の証明書を提示するようにクライアントに要求します。

この関数は、クライアントに対してmTLSプロセスの起動を *リクエスト* するものですが、 *強制* するものではありません。
クライアントがクライアント証明書を提示しなくても、TLSハンドシェイクは完了します。しかし、その場合、相互認証がないため、mTLS接続ではなくTLS接続を使用します。

クライアントがリクエストを承諾したかどうかを確認するには、後のフェーズで`get_full_client_certificate_chain` を使用します。

{% if_version gte:3.2.x %} `ca_certs` 引数はオプションの CA 証明書チェーンの不透明なポインターであり、[parse\_pem\_cert](https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md#parse_pem_cert) または [resty.opensslx509\.chain](https://github.com/fffonion/lua-resty-openssl#restyopensslx509chain) によって作成できます。CA 証明書の識別名（DN）リストに関する情報がクライアントに送信されます。省略すると、DN リストはクライアントに送信されません。
{% endif_version %}

**フェーズ** 

* certificate

{% if_version gte:3.2.x %}
**パラメータ** 

* **ca\_certs** （`cdata`、 *オプション* ）: CA証明書チェーンの不透明ポインタ{% endif_version %}

**戻り値** 

1. `true|nil`: 成功した場合は`true`を返し、失敗した場合は`nil`を返します。
2. `nil|err`: 成功した場合は`nil`を返し、失敗した場合はエラーメッセージを返します。

**使用方法**
{% if_version lte:3.1.x %}

```lua
local res, err = kong.client.tls.request_client_certificate()
if not res then
  -- do something with err
end
```

{% endif_version %}
{% if_version gte:3.2.x %}

```lua
local x509_lib = require "resty.openssl.x509"
local chain_lib = require "resty.openssl.x509.chain"
local res, err
local chain = chain_lib.new()
-- err check
local x509, err = x509_lib.new(pem_cert, "PEM")
-- err check
res, err = chain:add(x509)
-- err check
-- `chain.ctx` is the raw data of the chain, i.e. `STACK_OF(X509) *`
res, err = kong.client.tls.request_client_certificate(chain.ctx)
if not res then
  -- do something with err
end
```

{% endif_version %}

kong.client.tls.disable\_session\_reuse\(\)
-----------------------------------------------

現在のTLS接続のセッションチケットとセッションIDを無効にすることで、現在の接続のTLSセッションが再利用されないようにします。

**フェーズ** 

* certificate

**戻り値** 

1. `true|nil`: 成功した場合は`true`を返し、失敗した場合は`nil`返します。

2. `nil|err`: 成功した場合は`nil`を返し、失敗した場合はエラーメッセージを返します。

**使用方法** 

```lua
local res, err = kong.client.tls.disable_session_reuse()
if not res then
  -- do something with err
end
```

kong.client.tls.get\_full\_client\_certificate\_chain\(\)
---------------------------------------------------------------

クライアント証明書を先頭に、中間証明書（もしあれば）を末尾に持つ、PEM エンコードされたダウンストリームのクライアント証明書チェーンを返します。

**フェーズ** 

* rewrite, access, balancer, header\_filter, body\_filter, log

**戻り値** 

1. `string|nil`：mTLSハンドシェイクが完了した場合はPEMでエンコードされた
   クライアント証明書を返し、エラーが発生した場合またはクライアントが証明書を提示しなかった場合は
   `nil`を返します。

2. `nil|err`: 成功した場合は`nil`を返し、失敗した場合はエラーメッセージを返します。

**使用方法** 

```lua
local cert, err = kong.client.get_full_client_certificate_chain()
if err then
  -- do something with err
end

if not cert then
  -- client did not complete mTLS
end

-- do something with cert
```

kong.client.tls.set\_client\_verify\(\)
-------------------------------------------

ログシリアライザーによって生成されたクライアントの検証結果を上書きします。

デフォルトでは、Kongのログシリアライザーが生成したログ内の`request.tls.client_verify`フィールドは、
[$ssl\_client\_verify](https://nginx.org/en/docs/http/ngx_http_ssl_module.html#var_ssl_client_verify)
Nginx変数と同じです。

使用できる値は、`"SUCCESS"`、`"NONE"`、または `"FAILED:<reason id="sl-md0000000">"` のみです。

この関数は成功しても何も返さず、失敗した場合に備えてLuaエラーをスローします。

**フェーズ** 

* 書き換え、アクセス、バランサー

**使用方法** 

```lua
kong.client.tls.set_client_verify("FAILED:unknown CA")
```

